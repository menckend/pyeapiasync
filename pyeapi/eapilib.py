#
# Copyright (c) 2014, Arista Networks, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#   Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
#   Neither the name of Arista Networks nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARISTA NETWORKS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""Provides wrapper for eAPI calls

This module provides a connection to eAPI by wrapping eAPI calls in an
instance of Connection.  The connection module provides an easy implementation
for sending and receiving calls over eAPI using a HTTP/S transport.
"""

try:
    import json
    import logging
    import base64
    import socket
    import ssl
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        raise ImportError('No json library found')

from http.client import HTTPConnection, HTTPSConnection
from http.cookies import SimpleCookie

from pyeapi.utils import make_iterable

_LOGGER = logging.getLogger(__name__)

DEFAULT_HTTP_PORT = 80
DEFAULT_HTTPS_PORT = 443
DEFAULT_HTTP_LOCAL_PORT = 8080
DEFAULT_HTTPS_LOCAL_PORT = 8443
DEFAULT_HTTP_PATH = '/command-api'
DEFAULT_UNIX_SOCKET = '/var/run/command-api.sock'


def https_connection_factory(path, host, port, context=None, timeout=60):
    return HttpsConnection(path, host, port, context=context, timeout=timeout)


class EapiError(Exception):
    """Base exception class for all exceptions generated by eapilib

    This is the base exception class for all exceptions generated by
    eapilib.  It is provided as a catch all for exceptions and should
    not be directly raised by an methods or functions

    Args:
        commands (array): The list of commands there were sent to the
            node that when the exception was raised
        message (string): The exception error message
    """
    def __init__(self, message, commands=None):
        self.message = message
        self.commands = commands
        super(EapiError, self).__init__(message)


class CommandError(EapiError):
    """Base exception raised for command errors

    The CommandError instance provides a custom exception that can be used
    if the eAPI command(s) fail.  It provides some additional information
    that can be used to understand what caused the exception.

    Args:
        error_code (int): The error code returned from the eAPI call.
        error_text (string): The error text message that coincides with the
            error_code
        commands (array): The list of commands that were sent to the node
            that generated the error
        message (string): The exception error message which is a concatenation
            of the error_code and error_text
    """
    def __init__(self, code, message, **kwargs):
        cmd_err = kwargs.get('command_error')
        if int(code) in [1000, 1001, 1002, 1004]:
            msg_fmt = 'Error [{}]: {}'.format(code, message)
        else:
            msg_fmt = 'Error [{}]: {} [{}]'.format(code, message, cmd_err)

        super(CommandError, self).__init__(msg_fmt)
        self.error_code = code
        self.error_text = message
        self.command_error = cmd_err
        self.commands = kwargs.get('commands')
        self.output = kwargs.get('output')
        self.message = msg_fmt

    @property
    def trace(self):
        return self.get_trace()

    def get_trace(self):
        trace = list()
        index = None

        for index, out in enumerate(self.output):
            trace.append(out)
            if out.get('errors') or out.get('traceback'):
                break

        if index:
            trace.append({'executed_commands': self.commands[0:index]})

        return trace


class ConnectionError(EapiError):
    """Base exception raised for connection errors

    Connection errors are raised when a connection object is unable to
    connect to the node.  Typically these errors can result from using
    the wrong transport type or not providing valid credentials.

    Args:
        commands (array): The list of commands there were sent to the
            node that when the exception was raised
        connection_type (string): The string identifier for the connection
            object that generate the error
        message (string): The exception error message
        response (string): The message generate from the response packet

    """
    def __init__(self, connection_type, message, commands=None):
        self.message = message
        self.connection_type = connection_type
        self.commands = commands
        super(ConnectionError, self).__init__(message)


class SocketConnection(HTTPConnection):

    def __init__(self, path, timeout=60):
        HTTPConnection.__init__(self, 'localhost')
        self.path = path
        self.timeout = timeout

    def __str__(self):
        return 'unix:%s' % self.path

    def __repr__(self):
        return 'unix:%s' % self.path

    def connect(self):
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        self.sock.connect(self.path)


class HttpConnection(HTTPConnection):

    def __init__(self, path, *args, **kwargs):
        HTTPConnection.__init__(self, *args, **kwargs)
        self.path = path

    def __str__(self):
        return 'http://%s:%s/%s' % (self.host, self.port, self.path)

    def __repr__(self):
        return 'http://%s:%s/%s' % (self.host, self.port, self.path)


class HttpsConnection(HTTPSConnection):

    def __init__(self, path, *args, **kwargs):
        HTTPSConnection.__init__(self, *args, **kwargs)
        self.path = path

    def __str__(self):
        return 'https://%s:%s/%s' % (self.host, self.port, self.path)

    def __repr__(self):
        return 'https://%s:%s/%s' % (self.host, self.port, self.path)


class HTTPSCertConnection(HTTPSConnection):
    """ Class to make a HTTPS connection, with support
        for full client-based SSL Authentication.
    """

    def __init__(self, path, host, port, key_file, cert_file, ca_file,
                 timeout=None):
        HTTPSConnection.__init__(self, host, key_file=key_file,
                                 cert_file=cert_file)
        self.key_file = key_file
        self.cert_file = cert_file
        self.ca_file = ca_file
        self.timeout = timeout
        self.path = path
        self.port = port

    def __str__(self):
        return 'https://%s:%s/%s - %s,%s' % (self.host, self.port, self.path,
                                             self.key_file, self.cert_file)

    def __repr__(self):
        return 'https://%s:%s/%s - %s,%s' % (self.host, self.port, self.path,
                                             self.key_file, self.cert_file)

    def connect(self):
        """ Connect to a host on a given (SSL) port.
            If ca_file is pointing somewhere, use it
            to check Server Certificate.

            Redefined/copied and extended from httplib.py:1105 (Python 2.6.x).
            This is needed to pass cert_reqs=ssl.CERT_REQUIRED as parameter
            to ssl.wrap_socket() (Now changed to ssl.SSLContext.wrap_socket()
            as the former has been deprecated from python 3.7), which forces
            SSL to check server certificate against our client certificate.
        """
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if self._tunnel_host:
            self.sock = sock
            self._tunnel()
        # If there's no CA File, don't force Server Certificate Check
        if self.ca_file:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.verify_mode = ssl.CERT_REQUIRED
            context.check_hostname = False
            context.load_cert_chain(self.cert_file, self.key_file)
            context.load_verify_locations(self.ca_file)
            self.sock = context.wrap_socket(sock)
        else:
            ssl_context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            ssl_context.load_cert_chain(self.cert_file, self.key_file)
            self.sock = ssl_context.wrap_socket(sock)


class EapiConnection(object):
    """Creates a connection to eAPI for sending and receiving eAPI requests

    The EapiConnection object provides an implementation for sending and
    receiving eAPI requests and responses.  This class should not need to
    be instantiated directly.
    """

    def __init__(self):
        self.transport = None
        self.error = None
        self.socket_error = None
        self._auth = None

    def __str__(self):
        return 'EapiConnection(transport=%s)' % str(self.transport)

    def __repr__(self):
        return 'EapiConnection(transport=%s)' % repr(self.transport)

    def authentication(self, username, password):
        """Configures the user authentication for eAPI

        This method configures the username and password combination to use
        for authenticating to eAPI.

        Args:
            username (str): The username to use to authenticate the eAPI
                connection with
            password (str): The password in clear text to use to authenticate
                the eAPI connection with

        """
        _auth_text = '{}:{}'.format(username, password)
        _auth_bin = base64.encodebytes(_auth_text.encode())
        _auth = _auth_bin.decode().replace('\n', '')
        self._auth = ("Authorization", "Basic %s" % _auth)

        _LOGGER.debug('Authentication string is: {}:***'.format(username))

    def request(self, commands, encoding=None, reqid=None, **kwargs):
        """Generates an eAPI request object

        This method will take a list of EOS commands and generate a valid
        eAPI request object form them.  The eAPI request object is then
        JSON encoding and returned to the caller.

        eAPI Request Object

        .. code-block:: json

            {
                "jsonrpc": "2.0",
                "method": "runCmds",
                "params": {
                    "version": 1,
                    "cmds": [
                        <commands>
                    ],
                    "format": [json, text],
                }
                "id": <reqid>
            }

        Args:
            commands (list): A list of commands to include in the eAPI
                request object
            encoding (string): The encoding method passed as the `format`
                parameter in the eAPI request
            reqid (string): A custom value to assign to the request ID
                field.  This value is automatically generated if not passed
            **kwargs: Additional keyword arguments for expanded eAPI
                functionality. Only supported eAPI params are used in building
                the request

        Returns:
            A JSON encoding request structure that can be send over eAPI

        """
        commands = make_iterable(commands)
        reqid = id(self) if reqid is None else reqid
        params = {'version': 1, 'cmds': commands, 'format': encoding}
        streaming = False
        if 'apiVersion' in kwargs:
            params['version'] = kwargs['apiVersion']
        if 'autoComplete' in kwargs:
            params['autoComplete'] = kwargs['autoComplete']
        if 'expandAliases' in kwargs:
            params['expandAliases'] = kwargs['expandAliases']
        if 'streaming' in kwargs:
            streaming = kwargs['streaming']
        return json.dumps({'jsonrpc': '2.0', 'method': 'runCmds',
                           'params': params, 'id': str(reqid),
                           'streaming': streaming})

    def send(self, data):
        """Sends the eAPI request to the destination node

        This method is responsible for sending an eAPI request to the
        destination node and returning a response based on the eAPI response
        object.  eAPI responds to request messages with either a success
        message or failure message.

        eAPI Response - success

        .. code-block:: json

            {
                "jsonrpc": "2.0",
                "result": [
                    {},
                    {}
                    {
                        "warnings": [
                            <message>
                        ]
                    },
                ],
                "id": <reqid>
            }

        eAPI Response - failure

        .. code-block:: json

            {
                "jsonrpc": "2.0",
                "error": {
                    "code": <int>,
                    "message": <string>
                    "data": [
                        {},
                        {},
                        {
                            "errors": [
                                <message>
                            ]
                        }
                    ]
                }
                "id": <reqid>
            }

        Args:
            data (string): The data to be included in the body of the eAPI
                request object

        Returns:
            A decoded response.  The response object is deserialized from
                JSON and returned as a standard Python dictionary object

        Raises:
            CommandError if an eAPI failure response object is returned from
                the node.   The CommandError exception includes the error
                code and error message from the eAPI response.
        """
        try:
            debug_data = self._sanitize_request(data)
            _LOGGER.debug('Calling eAPI: {}'.format(debug_data))
            headers = {'Content-Type': 'application/json'}
            if self._auth:
                headers['Authorization'] = self._auth[1]

            self.transport.request('POST', self.transport.path, data, headers)
            response = self.transport.getresponse()
            decoder = response.read()
            decoded = decoder.decode('utf8')
            _LOGGER.debug('eAPI response: {}'.format(decoded))

        except OSError as exc:
            _LOGGER.exception('Socket error during eAPI call: %s', str(exc))
            self.socket_error = exc
            message = ('Socket error during eAPI call: {}'.format(str(exc)))
            raise ConnectionError(str(type(self)), message)

        except ValueError as exc:
            _LOGGER.exception('Unable to parse eAPI response: %s', str(exc))
            self.error = exc
            message = 'Unable to parse eAPI response: {}'.format(str(exc))
            raise ConnectionError(str(type(self)), message)

        finally:
            self.transport.close()

        decoded = json.loads(decoded)
        _LOGGER.debug('eAPI JSON response: {}'.format(decoded))

        if 'error' in decoded:
            cmd_err = self._parse_error_message(decoded['error']['message'])
            code = decoded['error']['code']
            message = decoded['error']['message']
            output = decoded['error'].get('data', list())
            commands = decoded['id']
            raise CommandError(
                code, message, command_error=cmd_err,
                output=output, commands=commands
            )

        return decoded

    def _sanitize_request(self, data):
        """remove user-sensitive input from data response"""
        try:
            data = json.loads(data)
            if data.get('params'):
                if 'enablepwd' in data['params']:
                    data['params']['enablepwd'] = '*' * 6
            return json.dumps(data)
        except ValueError:
            return data
        return data

    def _find_sub_json(self, jsn, sbj, instance=0):
        """Returns list of JSON value with the key node matching."""
        matching = []
        for key, value in jsn.items():
            if key == sbj:
                matching.append(value)
            elif isinstance(value, dict):
                res = self._find_sub_json(value, sbj, instance)
                if res:
                    matching.append(res)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        res = self._find_sub_json(item, sbj, instance)
                        if res:
                            matching.append(res)
        return matching[instance] if matching else None

    def _parse_error_message(self, message):
        """For legacy, raises the correct error message.

        There are several formats that have been available in EOS.
        """
        if '-' in message:
            err = message.split('-')
            # getattr returns something like
            # <bound method .__str__ of CommandError>
            # We want the result of the method call.

            if len(err) >= 3:
                return err[2]
            elif len(err) == 2:
                return err[1]
        return message

    def execute(self, commands, encoding='json', **kwargs):
        """Executes the commands on the destination node

        This method takes a list of commands and sends them to the
        destination node, returning the results.  The execute method handles
        putting the destination node in enable mode and will pass the
        enable password, if required.

        Args:
            commands (list): A list of commands to execute on the remote node
            encoding (string): The encoding to send along with the request
                message to the destination node.  Valid values include 'json'
                or 'text'.  This argument will influence the response encoding
            **kwargs: Arbitrary keyword arguments

        Returns:
            A decoded response message as a native Python dictionary object
            that has been deserialized from JSON.

        Raises:
            CommandError:  A CommandError is raised that includes the error
                code, error message along with the list of commands that were
                sent to the node.  The exception instance is also stored in
                the error property and is availble until the next request is
                sent
        """
        if encoding not in ('json', 'text'):
            raise TypeError('encoding must be one of [json, text]')

        reqid = id(self)
        request = self.request(commands, encoding=encoding,
                               reqid=reqid, **kwargs)
        response = self.send(request)
        return response['result']


class SocketEapiConnection(EapiConnection):
    def __init__(self, path=None, timeout=60, **kwargs):
        super(SocketEapiConnection, self).__init__()
        path = path or DEFAULT_UNIX_SOCKET
        self.transport = SocketConnection(path, timeout)


class HttpLocalEapiConnection(EapiConnection):
    def __init__(self, port=None, path=None, timeout=60, **kwargs):
        super(HttpLocalEapiConnection, self).__init__()
        port = port or DEFAULT_HTTP_LOCAL_PORT
        path = path or DEFAULT_HTTP_PATH
        self.transport = HttpConnection(path, 'localhost', port,
                                        timeout=timeout)


class HttpEapiConnection(EapiConnection):
    def __init__(self, host, port=None, path=None, username=None,
                 password=None, timeout=60, **kwargs):
        super(HttpEapiConnection, self).__init__()
        port = port or DEFAULT_HTTP_PORT
        path = path or DEFAULT_HTTP_PATH
        self.transport = HttpConnection(path, host, port, timeout=timeout)
        if username and password:
            self.authentication(username, password)


class HttpsEapiConnection(EapiConnection):
    def __init__(self, host, port=None, path=None, username=None,
                 password=None, context=None, timeout=60, **kwargs):
        super(HttpsEapiConnection, self).__init__()
        port = port or DEFAULT_HTTPS_PORT
        path = path or DEFAULT_HTTP_PATH
        self.transport = HttpsConnection(
            path, host, port, context=context, timeout=timeout
        )
        if username and password:
            self.authentication(username, password)

    def disable_certificate_verification(self):
        """Disables certificate verification for SSL connections

        This method will disable certificate verification for HTTPS
        connections to EOS nodes. This is typically used for environments
        that use self-signed certificates or certificates that are
        not issued by a trusted authority
        """
        import ssl
        ssl._create_default_https_context = ssl._create_unverified_context


class HttpsEapiCertConnection(EapiConnection):
    def __init__(self, host, port=None, path=None, key_file=None,
                 cert_file=None, ca_file=None, timeout=60, **kwargs):
        super(HttpsEapiCertConnection, self).__init__()
        port = port or DEFAULT_HTTPS_PORT
        path = path or DEFAULT_HTTP_PATH
        self.transport = HTTPSCertConnection(
            path, host, port, key_file, cert_file, ca_file, timeout
        )


class SessionApiConnection(object):
    def authentication(self, username, password):
        # We're going to add support to session
        # auth via a cookie (if available)
        self._auth = ('Cookie', 'Session=SSID')

        cookie = SimpleCookie()
        cookie.load('Session=SSID')

        if not cookie.get('Session'):
            # Build a header with a cookie
            _LOGGER.debug("Reauthenticating Session")
            super(SessionApiConnection, self).authentication(username,
                                                             password)


class HttpEapiSessionConnection(SessionApiConnection, HttpEapiConnection):
    pass


class HttpsEapiSessionConnection(SessionApiConnection, HttpsEapiConnection):
    pass
